<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ Primer Plus (6th Edition) [1/2]</title>
    <url>/2019/12/20/2019-12-26-cplusplus-note1/</url>
    <content><![CDATA[<p>This site was built using <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>.</p>
<ol>
<li><strong>Reference</strong>: <a href="https://isocpp.org/" target="_blank"><code>https://isocpp.org/</code></a></li>
<li><strong>Date</strong>: 2019.12.12</li>
</ol>
<hr>
<h1 id="C와-C-언어의-역사와-철학"><a href="#C와-C-언어의-역사와-철학" class="headerlink" title="C와 C++언어의 역사와 철학"></a>C와 C++언어의 역사와 철학</h1><p>일반적으로 컴퓨터 언어는 <strong><em>데이터</em></strong>와 <strong><em>알고리즘</em></strong>이라는 두가지 개념을 다룬다.</p>
<ul>
<li>데이터(data): 프로그램이 사용하고 처리하는 정보</li>
<li>알고리즘(algorithm): 프로그램이 데이터를 처리하는 방법</li>
</ul>
<h2 id="C의-프로그래밍-철학"><a href="#C의-프로그래밍-철학" class="headerlink" title="C의 프로그래밍 철학"></a>C의 프로그래밍 철학</h2><ul>
<li><code>C</code>는 절차적(procedural)언어이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">절차적이라는 말은 프로그래밍에서 데이터보다 알고리즘을 더 치중한다는 뜻이다.</span><br></pre></td></tr></table></figure>

<ul>
<li>절차적 프로그래밍은 컴퓨터가 수행해야 할 동작들을 명확히 구분하고, 그 구분된 동작들을 프로그래밍 언어로 구현하는 것이다.</li>
<li>원하는 결과를 얻기 위해 컴퓨터가 따라야 할 절차들을 규정해 놓은 것이 <code>절차적 프로그램</code>이다.</li>
</ul>
<h3 id="하향식-top-down-설계"><a href="#하향식-top-down-설계" class="headerlink" title="하향식(top-down)설계:"></a>하향식(top-down)설계:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 구조적 프로그래밍이 고수하는 또 하나의 철학</span><br><span class="line">- 규모가 큰 프로그램을 작고 쉽게 다룰 수 있는 최소한의 단위로 더욱 잘게 쪼개는 것</span><br><span class="line">- 전체 프로그램이 프로그래밍하기 쉬운 작은 모듈들의 집합이 될 때까지 계속해서 쪼개 나간다.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Cpp의-프로그래밍-철학"><a href="#Cpp의-프로그래밍-철학" class="headerlink" title="Cpp의 프로그래밍 철학"></a>Cpp의 프로그래밍 철학</h2><ul>
<li>구조적 프로그래밍 철학이 프로그램의 간결성과 신뢰성, 유지 보수의 용이성에 많은 향상을 가져온 것은 사실이나, 규모가 큰 프로그래밍은 여전히 어려운 문제로 남아 있었다.</li>
<li>이 문제의 해결책으로 <strong>객체 지향 프로그래밍</strong> 철학이 등장함.</li>
</ul>
<table>
<thead>
<tr>
<th>절차적 프로그래밍</th>
<th>객체 지향 프로그래밍</th>
</tr>
</thead>
<tbody><tr>
<td><code>알고리즘</code> 강조</td>
<td><code>데이터</code> 강조</td>
</tr>
</tbody></table>
<ul>
<li><p>객체 지향 프로그래밍은 해결해야 할 문제를 언어의 절차적 접근 방식에 억지로 끼워 맞추지 않고, 언어 자체를 해결해야 할 문제에 맞춘다.</p>
</li>
<li><p><strong><code>해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계한다.</code></strong></p>
</li>
<li><p>C++에서는 <code>클래스(Class)</code>가 그와 같은 목적으로 설계되는 새로운 데이터형이다.</p>
</li>
<li><p><code>객체(object)</code>는 그러한 클래스에 의해 만들어지는 특정한 데이터 구조이다.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>NOTE: OOP 환경에서는 모든 것을 <code>객체</code>로 표현하고, 이 객체의 형식을 갖는 변수를 <code>인스턴스(instance)</code>라고 한다.</th>
</tr>
</thead>
</table>
<h3 id="상향식-bottom-up-설계"><a href="#상향식-bottom-up-설계" class="headerlink" title="상향식(bottom-up)설계"></a>상향식(bottom-up)설계</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계로 진행하는 것</span><br><span class="line">- 객체 지향적으로 프로그램을 설계하라면 프로그램이 다루는 객체를 정확하게 서술하는 클래스를 먼저 설계해야 한다.</span><br><span class="line">- 각 클래스에 해당하는 객체를 만들면서 프로그램 설계를 진행하는 것을 상향식(bottom-up)프로그래밍이라 한다.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>NOTE: <code>설계</code> 와 <code>구현</code> 을 분리하는 것은 OOP의 중요한 특징 중 하나이다.</th>
</tr>
</thead>
</table>
<hr>
<h3 id="이-외의-OOP의-장점"><a href="#이-외의-OOP의-장점" class="headerlink" title="이 외의 OOP의 장점"></a>이 외의 OOP의 장점</h3><ul>
<li>OOP는 재활용이 가능한 소스 코드를 쉽게 작성할 수 있다.</li>
</ul>
<p><strong><em>정보 은닉</em></strong></p>
<ul>
<li>정보를 은닉할 수 있기 때문에 비인가된 접근으로부터 데이터를 안전하게 보호할 수 있음.</li>
</ul>
<p><strong><em>다형성(polymorphism)</em></strong></p>
<ul>
<li><code>다형성(polymorphism)</code>을 이용하여 이름이 같은 연산자와 함수를 여러 벌 정의할 수 있기 때문에 상황에 따라 적당한 연산자나 함수를 프로그램이 스스로 선택하게 할 수 있다.</li>
</ul>
<p><strong><em>상속(inheritance)</em></strong></p>
<ul>
<li>상속을 이용하여 하나의 클래스로부터 새로운 클래스를 유도하는 등 절차적 프로그래밍과는 완전히 다른 접근 방식을 취할 수 있음.</li>
</ul>
<hr>
<h1 id="Cpp와-일반화-프로그래밍"><a href="#Cpp와-일반화-프로그래밍" class="headerlink" title="Cpp와 일반화 프로그래밍"></a>Cpp와 일반화 프로그래밍</h1><ul>
<li>일반화 프로그래밍은 C++가 내걸고 있는 또 하나의 프로그래밍 철학이다.</li>
<li>일반화 프로그래밍과 OOP는 소스 코드의 재활용이라는 목표와, 포괄 개념의 추상화 기술을 서로 공유한다.</li>
<li>OOP는 <strong><em><code>데이터</code></em></strong> 를 강조하는 반면, 일반화 프로그래밍은 <strong><em><code>알고리즘</code></em></strong> 측면을 강조한다.</li>
</ul>
<table>
<thead>
<tr>
<th>객체 지향 프로그래밍</th>
<th>일반화 프로그래밍</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>데이터</code></strong> 를 강조</td>
<td><strong><code>알고리즘</code></strong> 를 강조</td>
</tr>
<tr>
<td>큰 프로젝트 진행시 좋음</td>
<td>데이터를 정렬(sort)하거나, 리스트를 병합(marge)하는 등의 일반적인 작업을 할 때 편리하다.</td>
</tr>
</tbody></table>
<ul>
<li>여기서 <code>일반화(generic)</code>이라는 말은 <strong><code>데이터형과 무관한 코드를 작성</code></strong> 한다는 것을 의미한다.</li>
</ul>
<hr>
<h1 id="C-전처리기와-iostream-파일"><a href="#C-전처리기와-iostream-파일" class="headerlink" title="C++ 전처리기와 iostream 파일"></a>C++ 전처리기와 <code>iostream</code> 파일</h1><ul>
<li>C와 마찬가지로 C++도 전처리기(preprocessor)를 사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">전처리기는 컴파일을 하기 전에 소스 파일에 대해 어떤 처리를 수행하는 프로그램이다.</span><br></pre></td></tr></table></figure>

<ul>
<li>전처리기는 소스 파일을 컴파일할 때 자동으로 생성된다.</li>
<li>전처리 지시자(directive)는 이름이 <code>#</code>으로 시작하는 지시자이다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //전처리 지시자</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>iostream</code>파일에는 C++의 몇 가지 입출력 기능이 정의되어 있다.</li>
<li>이 지시자는 전처리기에게 <code>iostream</code>파일의 내용을 프로그램에 추가하라고 지시한다.</li>
<li>컴파일되기 전에 소스 코드에 텍스트를 추가하거나 텍스트를 대체하는 것이 전처리기가 수행하는 기본적인 역할이다.</li>
</ul>
<hr>
<h1 id="이름-공간-namespace"><a href="#이름-공간-namespace" class="headerlink" title="이름 공간(namespace)"></a>이름 공간(namespace)</h1><ul>
<li><code>이름 공간</code>은 C++의 새로운 기능이다.</li>
<li>이름 공간은 프로그램을 작성할 때 여러 소프트웨어 개발업체들이 제공하는 코드를 사용할 수 있도록 도와준다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Microflop::wanda(<span class="string">"go dancing?"</span>); <span class="comment">//Microflop 이름 공간의 버전</span></span><br><span class="line">Piscine::wanda(<span class="string">"a fish named Desire"</span>); <span class="comment">//Piscine 이름 공간의 버전</span></span><br></pre></td></tr></table></figure>

<ul>
<li>이러한 방식에 의해, C++ 컴파일러의 표준 구성 요소인 <code>클래스</code>, <code>함수</code>, <code>변수</code>는 <code>std</code>라는 이름 공간안에 담겨진다.</li>
<li>이와 같은 일은 <code>.h</code> 확장자가 없는 헤더 파일들 안에서 일어난다.</li>
</ul>
<h2 id="using-지시자"><a href="#using-지시자" class="headerlink" title="using 지시자"></a>using 지시자</h2><ul>
<li>다음과 같은 행을 소스 코드에 넣으면 <code>std::</code>접두어를 붙이지 않고도 std 이름 공간에 정의되어 있는 이름들을 사용할 수 있다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>using</code> 지시자는 std 이름 공간에 들어있는 모든 이름을 사용할 수 있게 해 준다.</li>
</ul>
<hr>
<h1 id="C-소스-코드-스타일"><a href="#C-소스-코드-스타일" class="headerlink" title="C++ 소스 코드 스타일"></a>C++ 소스 코드 스타일</h1><ul>
<li>C++ 프로그램은 함수들의 집합이다.</li>
<li>이름 공간은 프로그램을 작성할 때 여러 소프트웨어 개발업체들이 제공하는 코드를 사용할 수 있도록 도와준다.</li>
</ul>
<h2 id="cin과-cout-클래스-맛보기"><a href="#cin과-cout-클래스-맛보기" class="headerlink" title="cin과 cout:클래스 맛보기"></a><code>cin</code>과 <code>cout:</code>클래스 맛보기</h2><ul>
<li><code>클래스</code>는 사용자가 정의하는 자료형이다.</li>
<li>클래스를 정의하려면, 클래스로 표현 할 수 있는 <code>정보의 종류</code>가 무엇이고, 그것으로 수행할 수 있는 <code>동작</code>은 무엇인지 서술해야 한다.</li>
<li>클래스와 객체의 관계는 데이터형과 변수의 관계와 같다.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>클래스</th>
<th>객체</th>
</tr>
</thead>
<tbody><tr>
<td>정의</td>
<td>데이터 형식과 그것이 사용되는 방법을 서술하는 것</td>
<td>클래스에 서술된 형식에 따라 실제로 생성되는 구체물</td>
</tr>
<tr>
<td>예시</td>
<td>유명 배우 (추상화적 개념)</td>
<td>제임스 딘 (클래스가 구체화된 객체)</td>
</tr>
</tbody></table>
<ul>
<li>이러한 비유를 더 확장시킨다면, <code>배우</code>라는 클래스에는 그 배우의 활동까지도 포함시킬 수 있다.</li>
<li>예를 들어, 대사 외우기, 반항아 이미지 표현하기 등등이 <code>배우</code>클래스의 동작이 될 수 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>NOTE: <strong>클래스</strong>는 데이터 형식의 모든 속성을 서술한 것이고, <strong>객체</strong>는 그 서술에 따라 실제로 생성된 구체물이다.</th>
</tr>
</thead>
</table>
<hr>
<ul>
<li>이제 <code>cout</code>을 살펴보자면,</li>
</ul>
<blockquote>
<p><strong>iostream</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">__PURE_APPDOMAIN_GLOBAL <span class="keyword">extern</span> _CRTDATA2_IMPORT istream <span class="built_in">cin</span>, *_Ptr_cin;</span><br><span class="line">__PURE_APPDOMAIN_GLOBAL <span class="keyword">extern</span> _CRTDATA2_IMPORT ostream <span class="built_in">cout</span>, *_Ptr_cout;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cout</code>은 <code>ostream</code>클래스의 속성을 가지고 생성된 객체이다.</li>
<li><code>ostream</code>클래스는 <code>iostream</code>파일에 정의되어 있다.</li>
<li><code>ostream</code>클래스 정의에는 ostream 객체가 표현할 수 있는 데이터 형식이나, 그 데이터 형식을 가지고 수행할 수 있는 동작, 예를 들어 문자열을 출력 스트림에 삽입하는 동작 등을 정의하고 있다.</li>
<li>마찬가지로 <code>cin</code>은 <code>istream</code>클래스의 속성을 가지고 생성된 객체이며, 이것 역시 <code>iostream</code> 파일에 정의되어 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>NOTE: 주의해야 할 점은 <code>cin</code>은 C언어의 <code>scanf(&quot;%s&quot;, str);</code>와 같이 문자열을 공백문자로 구분하기 때문에 문자열 추출 시 항상 구문(phrase)나 전체 문장(sentence)가 아닌 하나의 단어(word)를 추출한다.</th>
</tr>
</thead>
</table>
<ul>
<li>따라서 <code>cin</code>으로부터 전체 문장을 받기 위해서는 <code>getline</code>함수를 사용한다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ 11</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line">/_</span><br><span class="line">is: istream object from which characters are extracted.</span><br><span class="line">str: <span class="built_in">string</span> object where the extracted line is stored.</span><br><span class="line">The contents in the string before the call (if any) are discarded and replaced by the extracted line.</span><br><span class="line"></span><br><span class="line">Return value: The same as parameter is.</span><br><span class="line">_/</span><br><span class="line"></span><br><span class="line"><span class="comment">//Example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract to string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please, enter your full name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::getline (<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Get line from stream into string.</li>
<li>Extract characters from <code>is</code> and stores them into <code>str</code> until the delimitation character <code>delim</code> is found. (or the new line, <code>\n</code>).</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer Plus (6th Edition) [2/2]</title>
    <url>/2019/12/20/2019-12-26-cplusplus-note2/</url>
    <content><![CDATA[<p>This site was built using <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>.</p>
<ol>
<li><strong>Reference</strong>: <a href="https://isocpp.org/" target="_blank"><code>https://isocpp.org/</code></a></li>
<li><strong>Topic</strong>: 데이터 처리 (p.71 ~ p.103)</li>
</ol>
<hr>
<h2 id="데이터형"><a href="#데이터형" class="headerlink" title="데이터형"></a><strong>데이터형</strong></h2><p><code>자료형(Data Type)</code>은 <strong>‘일정 크기의 메모리에 저장된 정보를 해석하는 방법’</strong> 이다.</p>
<h3 id="C-에-내장된-데이터형"><a href="#C-에-내장된-데이터형" class="headerlink" title="C++에 내장된 데이터형"></a>C++에 내장된 데이터형</h3><ul>
<li>C++에 내장된 데이터형에는 <strong>기본형</strong>과 <strong>복합형</strong>이 있다.</li>
<li>C와 비교해봤을 때 복합형을 제외한 기본형은 크게 다르지 않다.</li>
<li><strong>기본형</strong><ol>
<li>정수를 포현할 수 있는 <code>정수형</code></li>
<li>소수부가 있는 수를 표현할 수 있는 <code>부동 소수점형</code></li>
</ol>
</li>
<li><strong>복합형</strong><ul>
<li>배열, 문자열, 포인터, 구조체, 클래스, etc.</li>
</ul>
</li>
</ul>
<p>C++11 표준에서는 몇몇 자료형이 새롭게 추가되었다.</p>
<table>
<thead>
<tr>
<th>자료형</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>long</td>
<td>64비트 정수(컴파일러에 따라 약간 다를 수 있음</td>
</tr>
<tr>
<td>char16_t</td>
<td>16비트 문자(ex. char16_t a = u’A’;)</td>
</tr>
<tr>
<td>char32_t</td>
<td>32비트 문자(ex. char32_t a = u’A’;)</td>
</tr>
<tr>
<td>auto</td>
<td>컴파일러가 자동으로 형식을 규정하는 자료형(ex. auto a = 10;)</td>
</tr>
<tr>
<td>decltype(expr)</td>
<td>expr과 동일한 자료형(ex.int a(10); decltype(a)y = 20;)</td>
</tr>
</tbody></table>
<ul>
<li><code>char16_t</code>와 <code>char32_t</code>는 <strong>유니코드 처리를 위한 자료형</strong>이다.</li>
<li><code>auto</code>의 경우 기존에 있던 자료형으로, 의미가 새롭게 바뀐 자료형이다.<ul>
<li><strong>초기값의 형식에 맞춰 선언하는 인스턴스의 형식이 ‘자동’으로 결정된다.</strong></li>
</ul>
</li>
<li>즉, <code>auto</code>나 <code>decltype(expr)</code>는 완전히 새로운 자료형이다.</li>
</ul>
<p>참고: <a href = "http://www.cplusplus.com/doc/tutorial/variables/">cplusplus.com</a></p>
<hr>
<h2 id="정수형"><a href="#정수형" class="headerlink" title="정수형"></a><strong>정수형</strong></h2><p><code>정수형</code>은 2, 98 등과 같이 소수부가 없는 수를 말한다.<br>컴퓨터의 메모리용량에는 한계가 있으므로 컴퓨터 언어는 정수들의 부분 집합만을 나타낼 수 있다.</p>
<h3 id="정수형의-종류"><a href="#정수형의-종류" class="headerlink" title="정수형의 종류"></a>정수형의 종류</h3><ul>
<li>C++에서는 프로그램에서 요구하는 특정 상황에 알맞은 정수형을 골라 사용할 수 있도록 여러 가지 정수형을 제공한다.</li>
<li>폭(width, 정수 저장 시 사용되는 메모리 크기)에 따라 크기 순서대로 나열하자면 다음과 같다.<ul>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>long long (C++11)</li>
</ul>
</li>
</ul>
<br>

<table>
<thead>
<tr>
<th>NOTE: <code>int</code>형은 컴퓨터가 가장 효율적으로 처리하는 정수 형식이다.</th>
</tr>
</thead>
</table>
<hr>
<h3 id="정수크기-계산-방법"><a href="#정수크기-계산-방법" class="headerlink" title="정수크기 계산 방법"></a>정수크기 계산 방법</h3><p>C++ 시스템의 정수 크기가 얼마인지 알고 싶으면, 데이터형의 크기를 알아내는 C++의 도구를 사용할 수 있다.</p>
<h4 id="1-sizeof연산자"><a href="#1-sizeof연산자" class="headerlink" title="1. sizeof연산자"></a>1. <code>sizeof</code>연산자</h4><ul>
<li><code>sizeof</code>연산자를 사용하면 변수나 데이터형의 크기를 바이트 단위로 리턴받아 데이터형의 크기를 알 수 있다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_int = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> n_int &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sizeof</code>연산자는 <code>int</code>와 같은 데이터형 이름에 사용할 때는 괄호를 사용해야 하며, <code>n_int</code>와 같은 변수이름에는 괄호가 없어도 상관없다.</li>
</ul>
<h4 id="2-climits-헤더파일"><a href="#2-climits-헤더파일" class="headerlink" title="2. climits 헤더파일"></a>2. <code>climits</code> 헤더파일</h4><ul>
<li>2번째 방법은 여러 가지 정수형들의 범위에 대한 정보가 들어 있는 <code>climits</code>헤더 파일을 열어 보는 것이다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n_int = INT_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char의 비트수 = "</span> &lt;&lt; CHAR_BIT &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">//CHAR_BIT: char형의 비트수를 정의</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// INT_MIN, SHRT_MAX, LONG_MAX, LLONG_MAX.. 등 각 데이터형의 최대, 최소값 등이 들어 있음</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sizeof</code>연산자는 <code>int</code>와 같은 데이터형 이름에 사용할 때는 괄호를 사용해야 하며, <code>n_int</code>와 같은 변수이름에는 괄호가 없어도 상관없다.</li>
</ul>
<hr>
<h3 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h3><h4 id="1-기존의-방식"><a href="#1-기존의-방식" class="headerlink" title="1. 기존의 방식"></a>1. 기존의 방식</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> owls = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-C-의-초기화-문법"><a href="#2-C-의-초기화-문법" class="headerlink" title="2. C++의 초기화 문법"></a>2. C++의 초기화 문법</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wrens</span><span class="params">(<span class="number">432</span>)</span></span>; <span class="comment">// C++의 새로운 초기화 문법, wrens를 432로 초기화</span></span><br></pre></td></tr></table></figure>

<h4 id="3-C-11에서의-초기화"><a href="#3-C-11에서의-초기화" class="headerlink" title="3. C++11에서의 초기화"></a>3. C++11에서의 초기화</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hamburger = &#123;<span class="number">24</span>&#125;; <span class="comment">// hamburger를 24로 초기화</span></span><br><span class="line"><span class="keyword">int</span> emus&#123; <span class="number">7</span> &#125;;        <span class="comment">// =를 사용할 수도, 사용하지 않을 수도 있다.</span></span><br><span class="line"><span class="keyword">int</span> rheas = &#123; <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> psychics&#123; &#125;; <span class="comment">// psychics를 0으로 초기화</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Overflow-Underflow-In-C"><a href="#4-Overflow-Underflow-In-C" class="headerlink" title="4. Overflow/Underflow In C++"></a>4. Overflow/Underflow In C++</h4><ul>
<li>C++에서 자료형이 표현할 수 있는 한계를 벗어나면 그 표현 버위의 반대편에서부터 다시 시작한다.</li>
<li>C++는 표현 한계값을 벗어날 때 (Overflow/Underflow 발생 시) <code>unsigned</code> 정수형의 경우 ‘0’ 또는 최대값으로 바뀌며,<br><code>signed</code> 정수형의 경우 최소값 또는 최대값으로 바뀐다.</li>
</ul>
<hr>
<h3 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h3><p><code>정수형 상수</code>는 212, 116과 같이 프로그램에 직접 써 넣는 정수를 말한다.<br>C++에서 프로그램에 쓸 수 있는 상수는 크게 <strong>8진수</strong>, <strong>10진수</strong>, <strong>16진수</strong>가 있다.</p>
<h4 id="1-정수값을-16진수나-8진수로-출력하려면"><a href="#1-정수값을-16진수나-8진수로-출력하려면" class="headerlink" title="1. 정수값을 16진수나 8진수로 출력하려면?"></a>1. 정수값을 16진수나 8진수로 출력하려면?</h4><ul>
<li>정수값을 16진수나 8진수로 출력하려면 <code>cout</code>의 특별한 기능을 사용해야 한다.</li>
<li><code>iostream</code>헤더 파일은 정수를 8진수, 10진수, 16진수로 각각 출력하라는 메세지를 <code>cout</code>에 전달하는 <strong><code>dec</code></strong>, <strong><code>hex</code></strong>, <strong><code>oct</code></strong> 조정자를 제공한다. (10진수가 default이다.)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10진수</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">15</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8진수</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">15</span> &lt;&lt; <span class="string">'\n'</span>;    <span class="comment">//17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//16진수</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">15</span> &lt;&lt; <span class="string">'\n'</span>;    <span class="comment">//f</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::cout &lt;&lt; std::oct</code></strong> 와 같은 코드는 화면에 아무것도 출력하지 않는다.</li>
<li>즉, 이 코드는 <strong>cout가 정수를 디스플레이하는 방식을 변경</strong>한다.</li>
</ul>
<h5 id="2진수-출력하는-방법"><a href="#2진수-출력하는-방법" class="headerlink" title="2진수 출력하는 방법"></a>2진수 출력하는 방법</h5><h6 id="1-lt-bitset-gt-헤더파일-이용"><a href="#1-lt-bitset-gt-헤더파일-이용" class="headerlink" title="1. &lt;bitset&gt; 헤더파일 이용"></a>1. <code>&lt;bitset&gt;</code> 헤더파일 이용</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//변수 선언 후 출력</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; ch_bits = <span class="number">15</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch_bits &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//형 변환 후 출력</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (class <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;CHAR_BIT&gt;)<span class="number">15</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="직접-함수-만들기"><a href="#직접-함수-만들기" class="headerlink" title="직접 함수 만들기"></a>직접 함수 만들기</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dec_To_Bin</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k = n &gt;&gt; i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//space per 'x4'</span></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; !(i % <span class="number">4</span>))</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-C-가-상수의-데이터형을-결정하는-방법"><a href="#2-C-가-상수의-데이터형을-결정하는-방법" class="headerlink" title="2. C++가 상수의 데이터형을 결정하는 방법"></a>2. C++가 상수의 데이터형을 결정하는 방법</h4><ul>
<li><strong>C++은 특별한 이유가 없다면 정수형 상수를 모두 <code>int</code> 형으로 저장한다.</strong></li>
<li>즉, 아래와 같은 경우가 예외의 경우이다.<ul>
<li>특정 데이터형을 의미하는 접미어를 상수에 붙였을 때</li>
<li>값이 너무 커서 <code>int</code>형으로 저장할 수 없을 때</li>
</ul>
</li>
<li>접미어<ol>
<li><code>l, L</code> –&gt; <code>long</code>형</li>
<li>‘u, U’ –&gt; <code>unsigned int</code>형</li>
<li><code>ul</code> –&gt; <code>unsigned long</code>형</li>
<li><code>ll, LL</code> –&gt; <code>unsinged long long</code>형</li>
</ol>
</li>
<li>접미어가 없는 10진 정수는 <code>int</code>, <code>long</code>, <code>long long</code>형 중에서 크기가 가장 작은 것으로 나타낸다.</li>
</ul>
<h2 id="Char-형"><a href="#Char-형" class="headerlink" title="Char 형"></a><strong>Char 형</strong></h2><p><code>자료형(Data Type)</code>은 <strong>‘일정 크기의 메모리에 저장된 정보를 해석하는 방법’</strong> 이다.</p>
<ul>
<li><code>Char</code> 형은 문자와 숫자를 저장하기 위한 것이다.</li>
<li>프로그래밍 언어는 문자를 <strong><code>수치 코드</code></strong> 로 나타냄으로써 컴퓨터가 문자를 저장할 수 있게 한다.</li>
<li>보통 이러한 <code>수치 코드</code>은 특정한 문자 세트(<strong><code>문자집합</code></strong>, 각 문자에 번호를 부여한 것 e.g.s., <code>ASCII</code>, <code>EBCDIC</code>, etc.)에 있는 각 문자에 대응된다.</li>
<li>미국에서 가장 많이 사용하는 문자세트는 <strong><code>ASCII</code></strong> 이다.</li>
<li>예를 들어 ASCII 문자 세트의 <code>A</code>라는 문자는 수치 코드 <code>65</code>로 나타낼 수 있다.</li>
<li>그러나 ASCII 같은 경우 국제적인 요구를 수용하지 못한다.</li>
<li>그래서 C++은 보다 넓은 범위의 값을 수용하는 <code>Unicode</code> 국제 문자 세트를 사용할 수 있는 <strong>확장 문자형 (<code>wchar_t</code>)</strong> 을 지원한다.</li>
</ul>
<hr>
<h4 id="문자집합-Character-Set-과-인코딩-Encoding-2-1"><a href="#문자집합-Character-Set-과-인코딩-Encoding-2-1" class="headerlink" title="문자집합(Character Set)과 인코딩(Encoding) [2/1]"></a>문자집합(Character Set)과 인코딩(Encoding) [2/1]</h4><p>컴퓨터는 수치 연산을 위해 설계되었다. 컴퓨터 발명 초기에는 문자를 표현해야 하는 요구가 없었다. 영어 단어 <code>compute</code>는 단순히 ‘계산하다’라는 뜻이고, 초창기의 컴퓨터와 ‘전자 계산기’는 동의어이기도 했다. 그러나 (너무나 당연하지만) 문자를 표현해야 하는 요구가 발생했다. 컴퓨터 간에 문자 데이터를 교환해야 할 일이 생기기도 했다. 이기종 컴퓨터끼리 문자 데이터를 교환하기 위해서는 표준이 필요하다. 이런 이유로 <code>ASCII</code>(American Standard Code for Information Interchange)와 같은 표준 문자 인코딩이 만들어졌다.</p>
<p>문자를 표현하기 위해서는 가장 먼저 <strong><code>문자 집합</code></strong> 을 정의해야 한다. 문자 집합은 표현해야 할 문자를 정하고 순서를 지정한 것이다. 영어라면 ‘A’, ‘B’, ‘C’에서 ‘Z’까지(소문자 a에서 z), 한글이라면 ‘가’, ‘각’, ‘간’에서 ‘힣’까지다. 물론 숫자나 특수 문자뿐만 아니라 인쇄와 통신을 제어하기 위한 제어 문자도 문자 집합에 포함되어야 한다. 이러한 문자 집합을 코드 형태(일반적으로 행렬)로 표기한 것을 <strong><code>코드화된 문자 집합</code></strong>(CCS, coded character set)이라고 한다. 예를 들어 ‘가’에는 10001, ‘각’에는 10002와 같이 코드를 할당하는 방식 말이다. 그리고 문자 집합을 컴퓨터에 저장하기 위해서 옥텟(octet, 8비트 단위) 형태로 표현한 것을 <strong><code>인코딩 방식</code></strong>(CES, character encoding scheme)이라고 한다.</p>
<p>출처: <a href = "https://d2.naver.com/helloworld/19187">한글 인코딩의 이해 1편: 한글 인코딩의 역사와 유니코드</a></p>
<hr>
<h4 id="문자집합-Character-Set-과-인코딩-Encoding-2-2"><a href="#문자집합-Character-Set-과-인코딩-Encoding-2-2" class="headerlink" title="문자집합(Character Set)과 인코딩(Encoding) [2/2]"></a>문자집합(Character Set)과 인코딩(Encoding) [2/2]</h4><p>유니코드를 설명하려면 <code>문자세트</code>와 <code>문자인코딩</code>이라는 용어를 구분해야 한다. 흔히 헷갈려 하는 용어다. <strong><code>문자세트</code></strong> 는 그야말로 문자들의 집합이다. 문자들의 집합에 각 문자에 번호를 부여한 것이다. <strong><code>문자인코딩</code></strong> 은 그런 문자들을 어떻게 코드를 할당하느냐를 나타낸 것이다. 문자세트를 특별한 변화 없이 그대로 1:1로 나타내는 문자인코딩도 있고, 별도의 규칙에 의해 변경해서 표기하는 문자인코딩도 있다. KSC5601은 문자세트고 이를 영문자와 합쳐서 그대로 인코딩 한것은 EUC-KR이다. 앞으로 문자세트와 인코딩을 마구 섞어서 사용할 것인데 혼동하지는 말자.</p>
<p>출처: <a href = "http://www.allofsoftware.net/2015/06/6.html">유니코드는 어떻게 탄생했을까? (6) - All of Software</a></p>
<hr>
<h4 id="유니코드는-어떻게-탄생했을까"><a href="#유니코드는-어떻게-탄생했을까" class="headerlink" title="유니코드는 어떻게 탄생했을까?"></a>유니코드는 어떻게 탄생했을까?</h4><p>1950년대 최초로 컴퓨터가 탄생하고 초창기 컴퓨터에는 표준 문자세트이라는 것이 없었다. 즉, 컴퓨터마다 다른 문자세트를 사용하고 있었다. 그래서 1967년 미국에서 표준 문자세트를 제정한 것이 <code>ASCII</code>다. 미국에서 만들었기 때문에 알파벳과 숫자 등의 글자로 이루어졌다.</p>
<p>ASCII는 7비트 128글자를 사용하며 거의 모든 문자세트의 기본이 된다. 하지만 ASCII는 유럽글자를 표현 할 수 없었다. 그래서 유럽 사람들은 1980년대 중반 ASCII를 확장하여 <strong><code>ISO-8859</code></strong> 를 만들게 된다. ISO-8859의 특징은 기존 ASCII 영역을 건들지 않고 8비트 128글자 영역을 사용하여 미국에서 작성한 문서도 그대로 볼 수 있게 하였다.</p>
<p><code>ISO-8859-1</code>은 네델란드어, 노르웨이어, 독일어 등 주로 서유럽의 언어를 지원한다.<br><code>ISO-8859-2</code>은 체코어, 폴란드어, 헝가리어 등 주로 중앙유럽의 언어를 지원한다.<br><code>ISO-8859-3</code>은 터키어 등 주로 남유럽의 언어를 지원한다. 이런 식으로 ISO-8859-16까지 추가되었는데 암기할 필요는 없다. ISO-8859를 사용해도 여러 유럽어를 동시에 표현할 수는 없었다.</p>
<p>그 무렵 아시아에서는 문자세트 혼란의 시기가 도래하였다.</p>
<p>한국에서는 1980년대 초부터 여러 가지 한글 조합형 인코딩을 사용했다. 1987년 <code>KSC5601</code>(KSX1001)이라는 한글(한국어) 완성형 문자세트가 제정된 후 조합형과 완성형은 공존을 하다 조합형은 사라지게 된다. 조합형과 완성형의 팽팽한 균형이 무너진 시점은 윈도우95가 나오면서부터다. 그럼에도 불구하고 그 당시 똠방박하의 “똠”자를 윈도우에서 쓸 수 없다는 것은 많은 이슈가 되었다.</p>
<p>중국과 일본도 제 각각의 문자세트와 인코딩을 정의해서 전세계, 특히 아시아는 문자세트 춘추 전국시대가 되었다. 한나라 안에서도 수많은 문자세트와 인코딩이 넘쳐나고 있었다. 이는 <strong>전세계 컴퓨터, 소프트웨어가 서로 호환되지 않는다는 의미</strong> 를 얘기한다. 알파벳과 숫자를 제외하고는 깨져버리기 일쑤였다.</p>
<p>하나의 인코딩으로 영어와 한국어는 표시할 수 있고, 영어와 일본어도 표현을 할 수 있다. 하지만 영어, 한국어, 일본어, 중국어 이렇게 다양한 언어를 한꺼번에 표현할 수는 없었다. 그래서 탄생한 것이 <code>ISO2022</code>다. 중간에 특수한 문자를 만나면 문자세트가 바뀌는 것이다. ISO2022 인코딩의 문자열은 중간부터 읽을 경우 무슨 문자인지 알 수 없는 약점이 있었다.</p>
<p>80, 90년대 이런 춘추전국 시대에 개발을 해본 개발자라면 이런 혼란을 잘 알고 있을 것이다. 근래에 개발을 시작한 개발자들에게는 먼 옛날 얘기일 것이다.</p>
<p>그 당시에는 대부분의 소프트웨어가 나라별 버전을 따로 만들곤 했다.</p>
<p>이러한 혼동 속에서 하나의 문자세트로 전세계 문자를 모두 표현하려는 움직임이 있었고, 썬마이크로시스템즈, 애플, MS, IBM, 볼랜드 등의 회사들이 유니코드컨소시엄을 만들어서 전세계 문자를 통합한 <strong><code>유니코드(Unicode)</code></strong> 를 만들기 시작했다. 참여한 회사들을 보면 거의 미국 회사인 것을 알 수 있다. 미국 회사들이 전세계에 소프트웨어를 팔다보니 본인들이 힘들어서 통합의 필요성을 느낀 것이다. 그렇게 미국이 주도하여 1991년 유니코드 1.0이 탄생한다.</p>
<p>출처: <a href = "http://www.allofsoftware.net/2015/06/6.html">유니코드는 어떻게 탄생했을까? (6) - All of Software</a></p>
<hr>
<h4 id="클래스와-맴버함수"><a href="#클래스와-맴버함수" class="headerlink" title="클래스와 맴버함수"></a>클래스와 맴버함수</h4><p>morechar.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cout.put()을 사용하여 문자 상수를 출력한다.</span></span><br><span class="line"><span class="built_in">cout</span>.put(<span class="string">'!'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cout.put()</code>은 C++ OOP에서 중요한 개념인 <code>맴버 함수</code>를 설명하는 첫 번째 예이다.</li>
<li>클래스(class)는 <code>데이터 형식</code>과 <code>그 데이터를 다루는 방법</code>을 정의해 놓은 것이다.</li>
<li>이때, 맴버 함수는 클래스에 속하고, 클래스의 데이터를 다루는 방법을 정의한다.</li>
<li>예를 들어 <code>ostream</code> 클래스는 문자를 출력하도록 설계된 <code>put()</code>이라는 맴버 함수를 가지고 있다.</li>
<li><code>맴버 함수</code>는 그 클래스의 특정 객체를 통해서만 사용할 수 있다.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; os = <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//os --&gt; ostream의 객체 cout의 참조자</span></span><br><span class="line">os.put(<span class="string">'!'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>이때 <code>os.put()</code>이 나타내는 의미는</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">클래스 객체인 os를 통해 클래스 맴버 함수인 put()을 사용하겠다는 뜻이다.</span><br></pre></td></tr></table></figure>

<ul>
<li>‘put()’ 함수는 <code>&lt;&lt;</code> 연산자를 사용하여 문자를 출력하는 것에 대한 대안이다.</li>
</ul>
<hr>
<h4 id="유니버설-네임-코드"><a href="#유니버설-네임-코드" class="headerlink" title="유니버설 네임 코드"></a>유니버설 네임 코드</h4><ul>
<li>C++ 표준은 기본적인 소스 문자 세트를 지원하면서 추가로 C++ 시스템이 <code>확장 소스 문자 세트</code>와 <code>확장 실행 문자 세트</code> 를 제공하는 것을 허용한다.</li>
<li>즉, C++은 특정 키보드와는 무관한 국제 문자들을 표현하는 매커니즘을 가지고 있다, 이것이 <code>유니버설 네임 코드</code>이다. (universal characters names)</li>
<li><code>유니버설 네임 코드</code>는 이스케이프 시퀀스를 사용하는 것과 비슷하다.</li>
<li>만국 문자의 이름은 <code>\u</code> 또는 <code>\U</code> 중 어느 하나로 시작하게 된다.</li>
<li><code>\u</code> 나 <code>\U</code> 뒤에는 16진수 숫자가 온다.</li>
<li>이 숫자들은 <code>ISO 10646</code> 코드를 나타낸다.</li>
<li>지금도 개발 중인 <code>ISO 10646</code> 국제 표준 문자 세트는 전 세계의 다양한 문자들을 일관되게 나타낼 수 있는 <code>수치 코드</code>를 제공한다.</li>
<li>C++ 시스템이 확장 문자를 지원한다면, 유니버설 네임 코드를 문자 상수로 식별자 또는 문자열에 사용할 수 있다.</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//유니버설 네임 코드 (Universal character name) --&gt; 'wchar_t'의 부호와 길이는 가변이다.</span></span><br><span class="line"><span class="comment">////'가'의 유니버설 네임 코드</span></span><br><span class="line"><span class="keyword">wchar_t</span> wch&#123; <span class="string">L'가'</span> &#125;;</span><br><span class="line"><span class="keyword">wchar_t</span> wch_16&#123; <span class="string">L'\uAC00'</span> &#125;;  <span class="comment">// UTF-16, '\uAC00' --&gt; Unicode Character “가” (U+AC00)</span></span><br><span class="line">wchar_t wch_32&#123; L'\U0000AC00' &#125;; //UTF-32</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="유니코드와-ISO-10646-사이의-차이점은-무엇인가"><a href="#유니코드와-ISO-10646-사이의-차이점은-무엇인가" class="headerlink" title="유니코드와 ISO 10646 사이의 차이점은 무엇인가?"></a>유니코드와 ISO 10646 사이의 차이점은 무엇인가?</h5><p>유니코드 컨소시움이 공표한 유니코드 표준은 실제로 구현 레벨 3에서 기본 다중언어용 영역(BMP)을 포함한다. <strong>두 표준 공히 모든 문자들은 같은 위치를 가지며 같은 명칭을 사용한다.</strong></p>
<p>유니코드 표준은 부가적으로 몇몇 문자와 관련된 훨씬 많은 언어 체계를 정의하고 있으며 일반적으로 양질의 인쇄 출판 시스템 구현을 위한 더 나은 참고 자료가 된다. 유니코드는 예를 들어 라틴어와 유태어를 혼합하는 양 방향 텍스트를 취급하므로써, 몇몇 언어의 프리젠테이션 양식을 렌더링하기 위한 알고리즘과 문자열 비교를 위한 알 고리즘 및 그 외 많은 것을 명시하고 있다.</p>
<p>다른 한편 ISO 10646 표준은 잘 알려진 ISO 8859 표준과 비교했을 때 간단한 문자셋 테이블 그 이상은 아니다. 이것은 표준과 관련된 몇몇 기술들을 명시하고, 몇몇 인 코딩 대안들을 정의하며, ISO 6429와 ISO 2022와 같은 다른 ISO 표준과 관련된 UCS를 사용하는 방법에 관한 세부 사항을 포함한다. ISO 표준과 밀접하게 관련된 다른 것들 도 있다. 예를 들면, UCS 문자열의 정렬에 관한 ISO 14651이 있다. ISO 10646-1 표준의 훌륭한 특징으로는 그것이 다섯가지 다른 스타일로 변형시켜 한중일 국가의 glyph 예를 제공한다는 것이다. 반면 유니코드 표준은 한중일 국가의 한자를 단지 중국 식으 로만 보여준다.</p>
<p>출처: <a href = "http://doc.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP-6.html">유니코드와 ISO 10646 사이의 차이점은 무엇인가?</a></p>
<hr>
<h4 id="확장-char형-wchar-t"><a href="#확장-char형-wchar-t" class="headerlink" title="확장 char형: wchar_t"></a>확장 char형: <code>wchar_t</code></h4><ul>
<li><p>때로는 프로그램이 1바이트로 표현할 수 없는 문자 세트(일본어, 중국어, 한국어 등..)를 처리해야 하는 경우가 있다.</p>
</li>
<li><p>C++은 이것을 두 가지 방법으로 처리한다.</p>
</li>
<li><p>확장 문자 세트가 시스템의 기본 문자 세트면, 컴파일 개발 업체가 <code>char</code>형을 처음부터 2바이트 또는 그 이상으로 만드는 방법</p>
</li>
<li><p>기본 문자 세트와 확장 문자 세트를 동시에 지원하는 방법</p>
</li>
<li><p>즉, 2번째 방법의 의미는 <code>char</code>형으로 기본 문자 세트를 나타내고, 확장 문자 세트는 <code>wchar_t</code>형으로 나타내는 것이다. (<strong>W</strong>ide <strong>char</strong>acter <strong>t</strong> ype)</p>
</li>
<li><p><code>wchar_t</code>형은 <code>기초 데이터형</code>(underlying type)이라고 부르는 정수형과 동일한 크기와 부호 속성을 가진다.</p>
</li>
<li><p>기초 데이터형은 시스템에 따라 다른데, 어떤 시스템에서는 <code>unsinged short</code>형일 수 있고, 다른 시스템에서는 <code>int</code>형이 될 수도 있다.</p>
</li>
</ul>
<p><code>sourceannotations.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WCHAR_T_DEFINED</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> short <span class="keyword">wchar_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WCHAR_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* _WCHAR_T_DEFINED */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>위의 코드에 따르면 내 개발 환경은 2바이트 <code>wchar_t</code>형을 사용하는 시스템이므로, 만약 <code>wchar_t bob[] = L&quot;tall&quot;</code>와 같이 쓴다면, 각 문자에 2바이트 씩 대입하여 메모리에 저장할 것이다.</li>
<li>즉, 시스템에 따라 <code>wchar_t</code>의 부호와 길이는 변할 수 있다. (가변적)</li>
<li><code>cin</code>과 <code>cout</code>은 입력과 출력을 <code>char</code>형 문자의 스트림으로 간주하기 때문에 <code>wchar_t</code>형을 처리하지 못한다.</li>
<li>최신 버전의 <code>iostream</code>헤더 파일은 <code>wchar_t</code>형 문자의 스트림을 처리하기 위해 <code>wcin</code>과 <code>wcout</code> 객체를 제공한다.</li>
<li>그리고 확장 문자 상수나 확장 문자 문자열은 그 앞에 <strong>L</strong>을 붙여서 나타낸다.</li>
</ul>
<h4 id="새로운-C-11형-char16-t와-char32-t"><a href="#새로운-C-11형-char16-t와-char32-t" class="headerlink" title="새로운 C++11형: char16_t와 char32_t"></a>새로운 C++11형: <code>char16_t</code>와 <code>char32_t</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++11 에서 추가된 데이터 형</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char16_t</span> ch1 = <span class="string">u'q'</span>; <span class="comment">//기본 16비트 문자</span></span><br><span class="line">char32_t ch2 = U'\U00022B'; //32비트 유니버설 문자 이름</span><br><span class="line"></span><br><span class="line"><span class="keyword">char16_t</span> ch_16 = <span class="string">u'\uAC00'</span>; <span class="comment">//char16_t 는 접두사 'u'를 사용</span></span><br><span class="line">char32_t ch_32 = U'\U0000AC00'; //char32_t는 접두사 'U'를 사용</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch_16 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="comment">//ac00</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch_32 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="comment">//ac00</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code> 과 같이 <code>_</code>를 가지고 있는 형들은 정수형의 일종이지만, 시스템에 따라 다를 수 있다.</li>
</ul>
<h4 id="Source-Code-locale-개념-setlocale-등"><a href="#Source-Code-locale-개념-setlocale-등" class="headerlink" title="Source Code(locale 개념, setlocale 등)"></a>Source Code(locale 개념, <code>setlocale</code> 등)</h4><h5 id="로케일-locale-이란"><a href="#로케일-locale-이란" class="headerlink" title="로케일(locale)이란?"></a>로케일(locale)이란?</h5><p><code>로케일</code>(locale [loukǽl] 로캘 / [loukάːl] 로칼)은 사용자의 언어, 국가뿐 아니라 사용자 인터페이스에서 사용자가 선호하는 사항을 지정한 매개 변수의 모임이다.</p>
<ul>
<li><strong>[일반 로케일 설정]</strong><ul>
<li>표시 언어 설정</li>
<li>숫자 형식 설정</li>
<li>날짜/시간 형식 설정</li>
<li>시간대 설정</li>
<li>일광 절약 시간 (DST) 설정</li>
<li>통화 형식 설정</li>
</ul>
</li>
</ul>
<p>출처: <a href = "https://ko.wikipedia.org/wiki/%EB%A1%9C%EC%BC%80%EC%9D%BC">wikipedia</a></p>
<hr>
<p>세계 여러 나라들은 각자 다른 문화(언어, 날짜, 시간 등)을 갖고 있다. 프로그램의 국제화(Internationalization, 줄여서 i18n)는 사용자로 하여금 프로그램 수행시 로케일이란 것에 의해 입맛에 맞는 환경을 선택할 수 있도록 만든 것을 말한다.</p>
<ul>
<li>예를 들어 어떤 프로그램의 메시지가 여러가지 언어로 주어져 있는 경우 이중에 어떤 언어의 것을 출력할 것인가를 사용자가 결정할 수 있는 것이다. - 그것을 가능하게 해 주는 수단이 바로 로케일이다. 이것은 단순히 메시지 뿐만이 아니고 숫자표현법, 날짜 또는 시간표현법 등 여러가지에 사용될 수 있다.</li>
<li>그것 각각을 우리는 <code>카테고리(category)</code>라고 부른다.</li>
<li>카테고리에는 LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME 가 있다.</li>
</ul>
<p>출처: <a href = "http://coffeenix.net/doc/misc/locale.html">로케일(Locale)에 관하여…</a></p>
<hr>
<h5 id="char-setlocale-int-Category-const-char-Locale"><a href="#char-setlocale-int-Category-const-char-Locale" class="headerlink" title="char* setlocale(int _Category, const char* _Locale)"></a>char* setlocale(int <code>_Category</code>, const char* <code>_Locale</code>)</h5><ul>
<li><p><strong><code>Introduction</code></strong> 1. <code>_Category</code>에는 프로그램의 로케일 정보의 어떤 부분을 변경할지 여부를 정수로 지정한다. 1. <code>_Locale</code>에는 로케일을 지정한다. 1. 함수는 유효한 로케일 및 카테고리를 지정하면, 로케일에 대한 문자열에 대한 포인터를 반환한다.<br>잘못된 경우 NULL 포인터를 반환하고 설정을 변경하지 않는다.</p>
</li>
<li><p><strong><code>Parameters</code></strong> 1. <strong><code>_Category</code></strong>: 언어 설정 카테고리 - <code>LC_ALL</code>: 모든 카테고리 - <code>LC_COLLATE</code>: strcoll(), _ stricoll(), wcscoll() _ wcsicoll(), strxfrm()의 각 함수 - <code>LC_CTYPE</code>: 문자 처리 함수 (<cctype>의 함수들, isdigit, isxdigit 등 포함 x인 경우도 있음) - <code>LC_MONETARY</code>: localeconv() 함수가 반환하는 통화 형식 정보 - <code>LC_NUMERIC</code>: 형식이 지정된 출력 루틴 및 데이터 변환 루틴의 소수점 문자, localeconv() 함수가 반환하는 비화폐 형식 정보의 소수점 문자 - <code>LC_TIME</code>: strftime() 함수와 wcsftime () 함수</p>
</li>
</ul>
<pre><code>1. **`_Locale`**: 변경하려는 언어설정 명칭

    - `setlocale(LC_ALL, nullptr);` 과 같이 작성한다면 아무런 언어 설정도 안했으므로 기본적인 언어 설정인 &quot;C&quot;로 리턴됨
    - `setlocale(LC_ALL, &quot;&quot;);` 와 같이 작성한다면 OS를 기반으로 한 지역언어 설정을 적용하게 된다.
        - 즉, 작성하고 있는 컴퓨터의 국가 설정 텍스트 모드로 변경됨.

    - 한글 설정 방법
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">""</span>);</span><br><span class="line">setlocale(LC_ALL, <span class="string">"kor"</span>); <span class="comment">//"Korean" 또는 "korean" 등도 됌.</span></span><br></pre></td></tr></table></figure></code></pre><hr>
<ul>
<li><strong><code>NOTE</code></strong></li>
</ul>
<ol>
<li><p>언어 설정을 원래대로 되돌리고 싶다면 이전 언어설정에 대한 문자열을 다시 setlocale을 통해서 설정해줘야 한다.</p>
</li>
<li><p>로케일 설정이 실제로 값 얻기 영향은 실행 환경에 따라 달라진다. 로케일 문자는 예를 들어 “korean”등 구현에 정의되어 있는 값 을 지정하여 언어를 한글로 설정할 수 있다. locale에 NULL 문자열을 지정하면 그 로케일은 처리계 정의의 네이티브 환경이다.</p>
</li>
<li><p>확실한 프로그램을 만들려면, <code>setlocale()</code> 함수의 반환 값을 확인하고, 로케일 설정이 실패했을 경우의 처리도 작성해야 한다.(실행하는 시스템이 한글를 지원하지 않으면 setlocale() 함수는 실패한다.)</p>
</li>
</ol>
<hr>
<p>출처: <a href = "https://araikuma.tistory.com/599">[프로그램 개발 지식 공유]</a><br>출처: <a href = "https://m.blog.naver.com/PostView.nhn?blogId=assortrockp&logNo=220764067554&proxyReferer=https%3A%2F%2Fwww.google.com%2F">c++ 및 api 언어설정에 대하여 알아보자.</a><br>참고: <a href = "https://m.blog.naver.com/PostView.nhn?blogId=tipsware&logNo=221235708158&proxyReferer=https%3A%2F%2Fwww.google.com%2F">멀티 바이트 문자와 지역(국가)코드</a></p>
<hr>
<h5 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h5><ol>
<li>10진수, 16진수, 8진수, 2진수 출력 방법</li>
<li><code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code> 사용법</li>
<li><code>setlocale()</code> 함수 및 <code>std::locale()</code> 활용</li>
</ol>
<hr>
<p><code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C Standard Library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Standard Library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//User-defined Library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TypeName.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dec_To_Bin</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k = n &gt;&gt; i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//space per 'x4'</span></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; !(i % <span class="number">4</span>))</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//참조자를 이용하여 출력</span></span><br><span class="line">	<span class="comment">//std::ostream&amp; os = std::cout;</span></span><br><span class="line">	<span class="comment">//std::istream&amp; is = std::cin;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//os.put('!');</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////10진수</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; 15 &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////8진수</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; std::oct;</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; 15 &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////16진수</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; std::hex;</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; 15 &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////2진수</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////변수 선언 후 출력</span></span><br><span class="line">	<span class="comment">//std::bitset&lt;8&gt; ch_bits = 15;</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; ch_bits &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////형 변환 후 출력</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; (class std::bitset&lt;CHAR_BIT&gt;)15 &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////함수를 이용하여 출력</span></span><br><span class="line">	<span class="comment">//Dec_To_Bin(15, 16);</span></span><br><span class="line">	<span class="comment">//Dec_To_Bin(15, 32);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//유니버설 네임 코드 (Universal character name) --&gt; 'wchar_t'의 부호와 길이는 가변이다.</span></span><br><span class="line">	<span class="comment">////'가'의 유니버설 네임 코드</span></span><br><span class="line">	<span class="keyword">wchar_t</span> wch&#123; <span class="string">L'가'</span> &#125;;</span><br><span class="line">	<span class="keyword">wchar_t</span> wch_16&#123; <span class="string">L'\uAC00'</span> &#125;;  <span class="comment">// UTF-16, '\uAC00' --&gt; Unicode Character “가” (U+AC00)</span></span><br><span class="line">	wchar_t wch_32&#123; L'\U0000AC00' &#125;; //UTF-32</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++11 에서 추가된 데이터 형</span></span><br><span class="line">	<span class="keyword">char16_t</span> ch_16 = <span class="string">u'\uAC00'</span>; <span class="comment">//char16_t 는 접두사 'u'를 사용</span></span><br><span class="line">	char32_t ch_32 = U'\U0000AC00'; //char32_t는 접두사 'U'를 사용</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch_16 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="comment">//ac00</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch_32 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="comment">//ac00</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">wchar_t</span> kor_wch[]&#123; <span class="string">L"안녕하세요"</span> &#125;;</span><br><span class="line">	<span class="keyword">wchar_t</span> chi_wch[]&#123; <span class="string">L"为什么"</span> &#125;;</span><br><span class="line">	<span class="keyword">wchar_t</span> ja_wch[]&#123; <span class="string">L"こんにちは"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *_korean, *_chinese, * _japen;</span><br><span class="line"></span><br><span class="line">	_korean = strdup(setlocale(LC_ALL, <span class="string">"ko-KR"</span>));</span><br><span class="line">	_chinese = strdup(setlocale(LC_ALL, <span class="string">"zh-CN"</span>));</span><br><span class="line">	_japen = strdup(setlocale(LC_ALL, <span class="string">"ja-JP"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set new locale</span></span><br><span class="line">	<span class="comment">//1. use setlocale (select the locale environment &amp; change or reset)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//set locale to korean</span></span><br><span class="line">	setlocale(LC_ALL, _korean);</span><br><span class="line">	<span class="built_in">std</span>::wcout &lt;&lt; <span class="string">"result[_korean]: "</span> &lt;&lt; kor_wch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set locale to chinese</span></span><br><span class="line">	setlocale(LC_ALL, _chinese);</span><br><span class="line">	<span class="built_in">std</span>::wcout &lt;&lt; <span class="string">"result[_chinese]: "</span> &lt;&lt; chi_wch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set locale to japen</span></span><br><span class="line">	setlocale(LC_ALL, _japen);</span><br><span class="line">	<span class="built_in">std</span>::wcout &lt;&lt; <span class="string">"result[_japen]: "</span> &lt;&lt; ja_wch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(_korean);</span><br><span class="line">	<span class="built_in">free</span>(_chinese);</span><br><span class="line">	<span class="built_in">free</span>(_japen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. use std locale (select the locale environment &amp; change or reset)</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; "Current local name: " &lt;&lt; std::locale().name() &lt;&lt; "\n\n";</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//std::locale::global(std::locale("ko-KR.UTF-8"));</span></span><br><span class="line">	<span class="comment">//std::wcout &lt;&lt; "Result[_korean]: " &lt;&lt; kor_wch &lt;&lt; '\n';</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//std::locale::global(std::locale("zh-CN.UTF-8"));</span></span><br><span class="line">	<span class="comment">//std::wcout &lt;&lt; "Result[_chinese]: " &lt;&lt; chi_wch &lt;&lt; '\n';</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//std::locale::global(std::locale("ja-JP.UTF-8"));</span></span><br><span class="line">	<span class="comment">//std::wcout &lt;&lt; "Result[_japen]: " &lt;&lt; ja_wch &lt;&lt; '\n';</span></span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
